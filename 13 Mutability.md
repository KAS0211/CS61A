# Mutability

## Objects

Object consist of data and behavior, bundled together to create abstractions.
A type of object is called a class; classed are first-class values in Python.
In Python, every value is an object and all objects have attributes.

## Example: Strings

```python
s = "Hello"
s.upper()  # "HELLO"
s.lower()  # "hello"
s.swapcase()  # "hELLO"
```

### Representing Strings: the ASCII Standard

```python
a = 'A'
ord(a)  # 65
hex(ord(a))  # '0x41'
```

### Representing Strings: the Unicode Standard

- Supports bidirectional display order
- A canonical name for every character
  - `U+0058`: LATIN CAPITAL LETTER X
  - `U+263a`: WHITE SMILING FACE
  - `U+2639`: WHITE FROWNING FACE

```python
>>> from unicodedata import name, lookup
>>> name('A')
'LATIN CAPITAL LETTER A'
>>> lookup('WHITE SMILING FACE')
'â˜º'
>>>lookup('WHITE SMILING FACE').encode()
b'\xe2\x98\xba'
```

## Mutation Operations

The same object can change in value throughout the course of computation. Only objects of mutable types can change.

```python
>>> L = [1, 2, 3]
>>> L.pop()
3
>>> L.remove(2)
>>> L
[1]
>>> L.extend([4, 5])
>>> L
[1, 4, 5]
>>> L[0:2] = [1, 2, 3, 4]
>>> L
[1, 2, 3, 4, 5]
```

```python
>>> numerals = {'I': 1, 'V': 5, 'X': 10} 
>>> numerals['L'] = 50
>>> numerals
{'I': 1, 'V': 5, 'X': 10, 'L': 50}
>>> numerals.pop('X')
10
>>> numerals.get('X')
```

Mutation can happen within a function call.
A function can change the value of any object in its scope.

```python
L = [1, 2, 3, 4]

def func():
    L[2:] = []

func()
print(L)  # The output is [1, 2]
```

## Tuples

Tuples are **immutable sequences**.

```python
>>> (1, 2, 3, 4)
(1, 2, 3, 4)
>>> 1, 2, 3, 4
(1, 2, 3, 4)
>>> ()
()
>>> tuple()
()
>>> tuple([1, 2])
(1, 2)
>>> 2,
(2,)
>>> (3, 4) + (5, 6)
(3, 4, 5, 6)
>>> 5 in (3, 4, 5)
True
>>> (1, 2, 3)[1:]
(2, 3)
```

Tuples are immutable values, so they can be used as keys in a dictionary.

```python
>>> {(1, 2): 3}
{(1, 2): 3}
>>> {(1, [2]): 3}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

Immutable values are **protected** from mutation.

```python
a = 1, 2, 3
s = "abc"

def func():
    a = 4, 5, 6
    s = "def"

func()
print(a, s)  # The output is: (1, 2, 3) abc
```

The value of an expression can change because of changes in names or objects.

- Name change:

  ```python
  x = 1
  x = 2
  ```
  
- Object mutation:

  ```python
  x = [1, 2]
  x.append(3)
  ```

An immutable sequence may still **change** if it contains a value as an element.

```python
s = ([1, 2], 3)
s[0] = 4  # An error occurs
s[0][0] = 4  # ([4, 2], 3)
```

## Mutation

A compound data objects hax an "identity" in addition to the pieces of which it is composed. A list is still "the same" list even if we change its contents.

```python
>>> a = [10]
>>> b = a
>>> b.append(20)
>>> a
[10, 20]
>>> b
[10, 20]
```

### Identity Operators

`<exp0> is <exp1>` evaluates to `True` if both `<exp0>` and `<exp1>` evaluates to the same object.

The opposite of `is` is called `is not`.

### Mutable Default Arguments

Mutable default arguments are **dangerous**.

A default argument value is part of a function value, not generated by a call.

```python
>>> def f(s=[]):
...     s.append(1)
...     return len(s)
... 
>>> f()
1
>>> f()
2
```

Every time `f` is called, `s` will be bound to the same object, which is how default arguments work.

## Mutable Functions

Mutable values can be used to define mutable functions.

Below is a function with behaviors that varies over time, which model a bank account that has a balance of $100.

```python
def make_withdraw_list(balance):
    b = [balance]

    def withdraw(amount):
        if amount > b[0]:
            return "Insufficient funds"
        b[0] -= amount
        return b[0]

    return withdraw


withdraw1 = make_withdraw_list(100)
withdraw2 = make_withdraw_list(100)
print(withdraw1(10))  # 90
print(withdraw2(20))  # 80
```

If `b` is not a mutable value, we cannot access `b` in the `withdraw` function.

@import "img/mutability-01.png" {width=400}
